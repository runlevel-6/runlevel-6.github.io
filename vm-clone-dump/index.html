<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by LibreOffice - see http://cgit.freedesktop.org/libreoffice/core/tree/filter/source/xslt for the code.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">- no title specified</title><meta name="DCTERMS.title" content="" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:12pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	<!-- "li span.odfLiEnd" - IE 7 issue-->
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	* { margin:0;}
	.P1 { font-size:10pt; margin-bottom:0in; margin-top:0in; font-family:Liberation Mono; writing-mode:page; }
	<!-- ODF styles with no properties representable as CSS -->
	 { }
	</style></head><body dir="ltr" style="max-width:8.5in;margin-top:0.7874in; margin-bottom:0.7874in; margin-left:0.7874in; margin-right:0.7874in; writing-mode:lr-tb; "><p class="P1">#!/bin/bash</p><p class="P1">#</p><p class="P1"># Ken Zahorec 2015-02-09</p><p class="P1">#</p><p class="P1"># This script prepares hypervisor VMs for backup and then clones them to a backup area using libvirt.</p><p class="P1"># It emphasizes backuppc processing by suspending any running VMs before calling virt-cone to create VM dumps in a desginated dump area.</p><p class="P1"># </p><p class="P1"># This script first looks for currently running VMs and suspends each of them.</p><p class="P1"># It calls virt-cone script on each of the suspended VMs</p><p class="P1"># It them enumerates the VMs in the shutoff state and runs virt-clone on each of them.</p><p class="P1"># Finally, it resumes the previously running VMs.</p><p class="P1"> </p><p class="P1"># NOTE: This script does NOT dump paused or transitioning VMs--these VMs are not dumped, so will not be backed up via backuppc.</p><p class="P1"># VMs need to be either shutdown (inactive) or running to be backed up.</p><p class="P1"># When the script changes. please keep the version number updated via "year.month.day.increment" as follows.</p><p class="P1">version="2015.02.09.00"</p><p class="P1"># Exit on use of non-set variables</p><p class="P1">set -o nounset</p><p class="P1"># Exit on any errors returned</p><p class="P1">set -o errexit</p><p class="P1"># target_script_dir is set to the directory where you run this script and also the location of the VMs dump data.</p><p class="P1">target_script_dir=/var/lib/libvirt/images/virt-backup</p><p class="P1"> </p><p class="P1"># define logfile, name of this script, a date-time stamp</p><p class="P1">logfile="dump.log"</p><p class="P1">lockfile="dump.lock"</p><p class="P1">dump_subdir="dump"</p><p class="P1">script_name=${0##*/}</p><p class="P1">date_time=$(date)</p><p class="P1">operation_type=""</p><p class="P1"> </p><p class="P1"> </p><p class="P1">###################################################</p><p class="P1">function print_run_time () {</p><p class="P1"> </p><p class="P1"># Get current time in seconds</p><p class="P1">script_now_sec=$(date +%s)</p><p class="P1"># Difference between now and start time is the run time<span> </span></p><p class="P1">script_run_time_sec=$((${script_now_sec}-${script_start_sec}))</p><p class="P1">script_run_time_min=$((${script_run_time_sec}/60))</p><p class="P1">script_run_time_hour=$((${script_run_time_min}/60))</p><p class="P1">script_run_time_day=$((${script_run_time_hour}/24)) # hopefully we need go no further</p><p class="P1"> </p><p class="P1">if [ ${script_run_time_day} -ge 2 ]; then</p><p class="P1"><span> run_time="approximately $script_run_time_day days"</span></p><p class="P1">elif [ ${script_run_time_hour} -ge 4 ]; then</p><p class="P1"><span> run_time="approximately $script_run_time_hour hours"</span></p><p class="P1">elif [ ${script_run_time_min} -ge 10 ]; then</p><p class="P1"><span> run_time="approximately $script_run_time_min minutes"</span></p><p class="P1">else</p><p class="P1"><span> run_time="$script_run_time_sec seconds"</span></p><p class="P1">fi</p><p class="P1"/><p class="P1">echo " ==&gt; elapsed $script_run_time_sec seconds"</p><p class="P1">echo " ==&gt; $operation_type required $run_time"</p><p class="P1">}</p><p class="P1"> </p><p class="P1"> </p><p class="P1">###################################################</p><p class="P1">function create_and_dump_temporary_clone () {</p><p class="P1"><span> # grab the first argument which contains the VM name to use</span></p><p class="P1"><span> vm_target="$1"</span></p><p class="P1"> </p><p class="P1"><span> date_time=$(date)</span></p><p class="P1"><span> echo "$date_time : create_and_dump_temporary_clone will attempt to dump VM $vm_target"</span></p><p class="P1"><span> clone_stamp="c"</span></p><p class="P1"> </p><p class="P1"><span> # Create the specific vm dump subdirectory if it does not already exist.</span></p><p class="P1"><span> mkdir -p "$DUMPDIR/$dump_subdir/$vm_target"</span></p><p class="P1"> </p><p class="P1"><span> # Overall name of the temporary clone can not exceed 50 characters or virt-clone will fail.</span></p><p class="P1"><span> # Use alternate clone stamp and shorten original name if character limit would exceed 50.</span></p><p class="P1"><span> if [ ${#i} -gt 48 ]; then</span></p><p class="P1"><span> </span><span> # We have to truncate the last part of the name because it it too long.</span></p><p class="P1"><span> </span><span> # Produce a 6 char unique postpend stamp for clone names xxxxxx (hour-minute-second)</span></p><p class="P1"><span> </span><span> alt_clone_stamp=$(date +%H%M%S)</span></p><p class="P1"><span> </span><span> # Truncate the original name</span></p><p class="P1"><span> </span><span> vm_target_short=${vm_target:0:42}</span></p><p class="P1"><span> </span><span> # Combine the truncated name with the clone stamp to create the alt_clone_name</span></p><p class="P1"><span> </span><span> alt_clone_name="$vm_target_short-$alt_clone_stamp"</span></p><p class="P1"><span> </span><span> echo "VM name $vm_target-$clone_stamp is greater than 50 characters. Using $alt_clone_name instead."</span></p><p class="P1"><span> </span><span> clone_name="$alt_clone_name"</span></p><p class="P1"><span> </span><span> sleep 1</span></p><p class="P1"><span> </span><span> # Sleep briefly to insure we never get an identical alt_clone_stamp during the same dump operation.</span></p><p class="P1"><span> </span><span> # We never want to produce a name collision when creating clones or they will fail.</span></p><p class="P1"><span> else</span></p><p class="P1"><span> </span><span> clone_name="$vm_target-$clone_stamp"</span></p><p class="P1"><span> fi</span></p><p class="P1"> </p><p class="P1"><span> # We need to enhance this area of the script to support multiple virtual drives on the VM.</span></p><p class="P1"><span> # Some vms can be setup with mutilple virtual hard disks. We need to enumerate them and provide</span></p><p class="P1"><span> # a target in the temporary clone for them by repeat of the -f parameter in the virt-clone command.</span></p><p class="P1"><span> # Use of the virsh command with domblklist parameter can help us here.</span><span> </span></p><p class="P1"><span> # v?? is VirtIO disk, h?? is VirtIDE disk, S?? is Virt SCSI</span></p><p class="P1"><span> # "-" imples a CDROM drive that is disonnected. For example:</span></p><p class="P1"><span> #</span></p><p class="P1"><span> # [root@et-virt105 virt-backup]# virsh domblklist puppetmaster-clone-initialstate</span></p><p class="P1"><span> # Target     Source</span></p><p class="P1"><span> # ------------------------------------------------</span></p><p class="P1"><span> # vda        /var/lib/libvirt/images/puppetmaster-clone-initialstate.img</span></p><p class="P1"><span> # vdb        /var/lib/libvirt/images/puppetmaster-clone-initialstate-1.img</span></p><p class="P1"><span> # hda        /var/lib/libvirt/images/puppetmaster-clone-initialstate-2.img</span></p><p class="P1"><span> # hdc        -</span></p><p class="P1"><span> # sda        /var/lib/libvirt/images/puppetmaster-clone-initialstate-3.img</span></p><p class="P1"><span> #</span></p><p class="P1"><span> # We can pull information we need from the list. Generally speaking, the number</span></p><p class="P1"><span> # of filespecs in the list imply the number of virtual storage devices.</span></p><p class="P1"><span> # Something as simple as this:</span></p><p class="P1"><span> #</span></p><p class="P1"><span> # [root@et-virt105 virt-backup]# virsh domblklist puppetmaster-clone-initialstate | grep /</span></p><p class="P1"><span> # vda        /var/lib/libvirt/images/puppetmaster-clone-initialstate.img</span></p><p class="P1"><span> # vdb        /var/lib/libvirt/images/puppetmaster-clone-initialstate-1.img</span></p><p class="P1"><span> # hda        /var/lib/libvirt/images/puppetmaster-clone-initialstate-2.img</span></p><p class="P1"><span> # sda        /var/lib/libvirt/images/puppetmaster-clone-initialstate-3.img</span></p><p class="P1"><span> #</span></p><p class="P1"><span> # Use of virt-clone:</span></p><p class="P1"><span> # We can pass more "-f" option entries than virtual disks, it will populate only</span></p><p class="P1"><span> # as many as it needs. Read-only drives will remain rooted to the original in the</span></p><p class="P1"><span> # system in the new clone XML file. Read-only virtual storage drives are not dumped. </span></p><p class="P1"> </p><p class="P1"><span> num_drives=$(virsh domblklist ${vm_target} | grep / | wc -l)</span></p><p class="P1"><span> echo "VM $vm_target has $num_drives virtual disks"</span></p><p class="P1"><span> </span></p><p class="P1"><span> # Check number of virtual drives to make sure there are no more than 5, a reasonable limit.</span></p><p class="P1"><span> if [ ${num_drives} -le 5 ]; then</span></p><p class="P1"><span> </span><span> echo "$date_time : calling virt-clone to clone vm $vm_target ---&gt; $clone_name"</span></p><p class="P1"> </p><p class="P1"><span> </span><span> set +e # Disable errexit...keep chugging even if the virt-clone commands fail for this particular VM.</span></p><p class="P1"><span> </span><span> # The command pipe to grep below reduces a rather lengthy output of continued progress updates during virt-clone process.</span></p><p class="P1"><span> </span><span> virt-clone --connect=qemu:///system -o "$vm_target" -n "$clone_name" \</span></p><p class="P1"><span> </span><span>  -f "$DUMPDIR/$dump_subdir/$vm_target/$clone_name-1.img" \</span></p><p class="P1"><span> </span><span>  -f "$DUMPDIR/$dump_subdir/$vm_target/$clone_name-2.img" \</span></p><p class="P1"><span> </span><span>  -f "$DUMPDIR/$dump_subdir/$vm_target/$clone_name-3.img" \</span></p><p class="P1"><span> </span><span>  -f "$DUMPDIR/$dump_subdir/$vm_target/$clone_name-4.img" \</span></p><p class="P1"><span> </span><span>  -f "$DUMPDIR/$dump_subdir/$vm_target/$clone_name-5.img" | grep ${clone_name}</span></p><p class="P1"> </p><p class="P1"><span> </span><span> # Copy both the original VM XML and the temporary cloned VM XML files to the dump area.</span></p><p class="P1"><span> </span><span> cp -pv  "/etc/libvirt/qemu/$vm_target.xml"  "$DUMPDIR/$dump_subdir/$vm_target"</span></p><p class="P1"><span> </span><span> cp -pv  "/etc/libvirt/qemu/$clone_name.xml"  "$DUMPDIR/$dump_subdir/$vm_target"</span></p><p class="P1"><span> </span><span> </span></p><p class="P1"><span> </span><span> # Undefine the clone. This does not delete the clones disk(s) image(s), which remain in the dump area.</span></p><p class="P1"><span> </span><span> echo "$date_time : calling virsh undefine to remove temporary clone $clone_name"</span></p><p class="P1"><span> </span><span> virsh undefine "$clone_name"</span></p><p class="P1"><span> </span><span> set +e # Return to normal errexit bahavior. Exit script on any errors.</span></p><p class="P1"> </p><p class="P1"><span> </span><span> # Check to see if the image was created. If virt disk is read-only in VM, it will not get dumped.</span></p><p class="P1"><span> </span><span> # We need to get this information to the log file. Users need to know that read-only drives will</span></p><p class="P1"><span> </span><span> # not get dumped for backup.</span></p><p class="P1"><span> </span><span> date_time=$(date)</span></p><p class="P1"><span> </span><span> for index in $(seq 1 ${num_drives});</span></p><p class="P1"><span> </span><span> do</span></p><p class="P1"><span> </span><span> </span><span> if [ -e "$DUMPDIR/$dump_subdir/$vm_target/${clone_name}-${index}.img"  ]; then</span></p><p class="P1"><span> </span><span> </span><span> </span><span> echo -e "$date_time : SUCCESS - dump virtual storage disk ${clone_name}-${index} succeeded \n"</span></p><p class="P1"><span> </span><span> </span><span> else</span></p><p class="P1"><span> </span><span> </span><span> </span><span> # Copy of the vm virtual storage disk image failed</span></p><p class="P1"><span> </span><span> </span><span> </span><span> echo "$date_time : WARNING - dump of virtual storage volume ${clone_name}-${index} ==&gt; FAILED &lt;=="</span></p><p class="P1"><span> </span><span> </span><span> </span><span> echo -e "==&gt; Review VM settings. Perhaps a mounted CDROM image or other type of read-only storage is mounted.\n"</span></p><p class="P1"><span> </span><span> </span><span> fi</span></p><p class="P1"><span> </span><span> done</span></p><p class="P1"><span> else</span></p><p class="P1"><span> </span><span> echo "====&gt; ERROR : VM $vm_target has more than 5 virtual disks, it will not be dumped."</span></p><p class="P1"><span> fi</span></p><p class="P1">}</p><p class="P1">#########################################################</p><p class="P1">#########################################################</p><p class="P1"># Script processing basically starts here</p><p class="P1"> </p><p class="P1">################# script logging control ############</p><p class="P1"># FOR DEBUGGING USE ONLY: From this point onward, all console std out and std</p><p class="P1"># err output gets appended to the log file.  Normally we do not use this as all</p><p class="P1"># stream outputs go to the backuppc logs for this host.  If script is not run</p><p class="P1"># from backup area and we used this feature, we would lose log information.</p><p class="P1"># exec 3&gt;&amp;1 1&gt;&gt;${logfile} 2&gt;&amp;1</p><p class="P1"> </p><p class="P1">############### script dependencies check ###########</p><p class="P1">### check for virsh</p><p class="P1">if ! [ -x "$(command -v virsh)" ]; then</p><p class="P1">  echo 'The virsh utility appears to be missing. This script is designed for KVM/Qemu/libvirt systems.' &gt;&amp;2</p><p class="P1">  exit</p><p class="P1">fi</p><p class="P1">### check for virt-clone</p><p class="P1">if ! [ -x "$(command -v virt-clone)" ]; then</p><p class="P1">  echo 'The virt-clone utility appears to be missing. Perhaps install package virt-install.' &gt;&amp;2</p><p class="P1">  exit</p><p class="P1">fi</p><p class="P1"> </p><p class="P1"># Set defaults</p><p class="P1">DUMPDIR="/var/lib/libvirt/images/virt-backup"</p><p class="P1">CONCURRENT=0</p><p class="P1">DUMP=0</p><p class="P1">CLEAN=0</p><p class="P1">HELP=0</p><p class="P1"> </p><p class="P1">for i in "$@"</p><p class="P1">do</p><p class="P1"># echo "    $i"</p><p class="P1">case $i in</p><p class="P1"><span> -d=*|--dumpdir=*)</span></p><p class="P1"><span> DUMPDIR=`echo $i | sed 's/[-a-zA-Z0-9]*=//'`</span></p><p class="P1"><span> # If present, remove a trailing slash</span></p><p class="P1"><span> DUMPDIR=${DUMPDIR%/}</span></p><p class="P1"><span> ;;</span></p><p class="P1"><span> -o|--concurrent)</span></p><p class="P1"><span> CONCURRENT=1</span></p><p class="P1"><span> DUMP=1</span></p><p class="P1"><span> ;;</span></p><p class="P1"><span> -d|--dump)</span></p><p class="P1"><span> DUMP=1</span></p><p class="P1"><span> ;;</span></p><p class="P1"><span> -c|--clean)</span></p><p class="P1"><span> CLEAN=1</span></p><p class="P1"><span> operation_type="dump cleanup"</span></p><p class="P1"><span> ;;</span></p><p class="P1"><span> -h|--help)</span></p><p class="P1"><span> HELP=1</span></p><p class="P1"><span> ;;</span></p><p class="P1"><span> *)</span></p><p class="P1"><span> echo "==&gt;WARNING: An unknown or unsupported parameter: $i"</span></p><p class="P1"><span> HELP=1</span></p><p class="P1"><span> ;;</span></p><p class="P1">esac</p><p class="P1">done</p><p class="P1"> </p><p class="P1">if [ $HELP -eq 1 ]; then</p><p class="P1">echo -e "$script_name version $version help information:\nUsage:\n"</p><p class="P1">echo -n "  $script_name"</p><p class="P1">echo -e ' [ -d | --dump ]|[ -o | --concurrent ] [ -c | --clean ][ -d=(dir) | --dumpdir=(dir) ] [-h | --help]</p><p class="P1">----------------------------------------------------------------------------</p><p class="P1">  This script is designed to be used for pre-backup and post-backup dump and</p><p class="P1">  cleanup operations in conjunction with BackupPC or any other enterprise grade</p><p class="P1">  backup facility. This script provides a data dump of VM data at the</p><p class="P1">  hypervisor. It is designed to work with KVM/Qemu/libvirtd systems. It has been</p><p class="P1">  tested and used on CentOS v6.X and CentOS v7 systems.</p><p class="P1">  Seems reasonable that this script would run on Debian based KVM/Qemu/Libvirt</p><p class="P1">  systems as well.</p><p class="P1"> </p><p class="P1">  This script should be used during non-essential or non-business user times.</p><p class="P1">  It causes stress at the hypervisor due to the intense amount of IO required</p><p class="P1">  to move vm data.</p><p class="P1">-----------                                                 -------------------</p><p class="P1">Options are described below:</p><p class="P1"> </p><p class="P1"> -d | --dump</p><p class="P1">  Perform a normal clone dump operation of all running and shutdown VMs at the</p><p class="P1">  hypervisor.  This pauses all running VMs before cloning and dumping them.</p><p class="P1">  After dumping each vm, all of the previously running vms are then resumed.</p><p class="P1">  This provides least load at the hypervisor, but will result in unavailable</p><p class="P1">  vms during the time it takes the system to dump all of the vm data.</p><p class="P1"> </p><p class="P1"> -o | --concurrent</p><p class="P1">  Perform a high availability dump operation of all running and shutdown VMs at</p><p class="P1">  the hypervisor.  This will pause VMs individually and perform the clone dump,</p><p class="P1">  while other VMs remain running.</p><p class="P1"> </p><p class="P1">  On less capable servers, concurrent dumps can impact vm user experience</p><p class="P1">  because of limited IO capacity.  During the dump, other running VMs can</p><p class="P1">  become generally unresponsive resulting in user complaints. On more capable</p><p class="P1">  servers this option can limit vm downtime during dump operations.</p><p class="P1"> </p><p class="P1"> -c | --clean</p><p class="P1">  Perform a cleanup of the dumpdir location. This removes the dump lockfile and</p><p class="P1">  deletes all files that were previously dumped. It clears out the dump area to</p><p class="P1">  ready it for a future dump operation.</p><p class="P1"> </p><p class="P1"> -d=(dir) | --dumpdir=(dir)</p><p class="P1">  Specifying the dumpdir is not required, unless you want to use something other</p><p class="P1">  that the default value. The default dumpdir is</p><p class="P1">                                 /var/lib/libvirt/images/virt-backup</p><p class="P1">------------- Additional Info</p><p class="P1">  </p><p class="P1">  The dumpdir specified is used as the *parent* dump control directory. The</p><p class="P1">  dump subdirectory, "dump/", below the parent, is the actual target directory</p><p class="P1">  for the vm dump data. The dumpdir contains the lockfile control file and</p><p class="P1">  typically this script.</p><p class="P1">  </p><p class="P1">  You can place this script in the dumpdir and run it from there. This way you</p><p class="P1">  will get the very same script used for dumping, and cleanup, included in the</p><p class="P1">  backup data and it will remain on the system for backup use. Be sure to</p><p class="P1">  specify the dumpdir as the backup target in the BackupPC configuration for</p><p class="P1">  the hypervisor host.</p><p class="P1"> </p><p class="P1">  This script will not dump paused, or transitional vms. It will dump vms which</p><p class="P1">  are active running and/or inactive shutdown at invocation time. It will not</p><p class="P1">  dump images of vms which have their virtual disks set to read-only--it will</p><p class="P1">  dump only the vm XML for these vms.</p><p class="P1"> </p><p class="P1">  This script has not been tested with vms which are run without storage.</p><p class="P1">  Furthermore it requires that the vm be setup with a single virtual disk.</p><p class="P1">  Support for vms with multiple virtual disks is planned for near future.</p><p class="P1">'</p><p class="P1">exit</p><p class="P1">fi</p><p class="P1"> </p><p class="P1">echo "$date_time : **************** BEGIN $script_name version $version"</p><p class="P1"> </p><p class="P1"># Get current time in seconds</p><p class="P1">script_start_sec=$(date +%s)</p><p class="P1"> </p><p class="P1">if [ $CLEAN -eq 1 ]; then</p><p class="P1">echo " ==&gt; Dump cleanup is requested. Proceeding..."</p><p class="P1"><span> # Cleanup the lock file</span></p><p class="P1"><span> if [ -e $DUMPDIR/${lockfile}  ]; then</span></p><p class="P1"><span> </span><span> # Lockfile exists, delete it.</span></p><p class="P1"><span> </span><span> echo "Deleting $DUMPDIR/$lockfile ..."</span></p><p class="P1"><span> </span><span> rm -f "$DUMPDIR/$lockfile"</span></p><p class="P1"><span> else</span></p><p class="P1"><span> </span><span> # Lockfile does not exist. Warn and continue.</span></p><p class="P1"><span> </span><span> echo "$DUMPDIR/$lockfile was not detected - continuing anyway ..."</span></p><p class="P1"><span> fi</span></p><p class="P1"> </p><p class="P1"><span> # Cleanup the dump area</span></p><p class="P1"><span> if [ -e $DUMPDIR/${dump_subdir}  ]; then</span></p><p class="P1"><span> </span><span> echo "Deleting data found at $DUMPDIR/$dump_subdir"</span></p><p class="P1"><span> </span><span> rm -rf "$DUMPDIR/$dump_subdir"</span></p><p class="P1"><span> else</span></p><p class="P1"><span> </span><span> echo "No VM dump data detected at $DUMPDIR/$dump_subdir"</span></p><p class="P1"><span> fi</span></p><p class="P1"> </p><p class="P1"><span> # Keep the dump-subdir directory available for possible manual restores from the backup server.</span></p><p class="P1"><span> # This may not be needed for restoration from backup server. It is here as a safeguard.</span></p><p class="P1"><span> echo "create new empty dump area $DUMPDIR/$dump_subdir"</span></p><p class="P1"><span> mkdir -p "$DUMPDIR/$dump_subdir"</span></p><p class="P1"> </p><p class="P1"><span> print_run_time</span></p><p class="P1"> </p><p class="P1"><span> date_time=$(date)</span></p><p class="P1"><span> echo "$date_time : **************** COMPLETED $script_name"</span></p><p class="P1"> </p><p class="P1"><span> # We are done, nothing else to do.</span></p><p class="P1"><span> exit</span></p><p class="P1">fi</p><p class="P1"> </p><p class="P1">if [ $DUMP -eq 1 ]; then</p><p class="P1"><span> operation_type="STANDARD IDLE dump"</span><span> </span></p><p class="P1"><span> echo " ==&gt; Dump operation is requested"</span></p><p class="P1"><span> echo " Parent dumpdir path is = $DUMPDIR"</span></p><p class="P1"><span> echo " VM dump data path is = $DUMPDIR/$dump_subdir"</span></p><p class="P1">fi</p><p class="P1"> </p><p class="P1">if [ $CONCURRENT -eq 1 ]; then</p><p class="P1"><span> operation_type="CONCURRENT dump"</span><span> </span></p><p class="P1"><span> echo " ==&gt; A dump of type CONCURRENT is requested"</span></p><p class="P1">fi</p><p class="P1"> </p><p class="P1"># At this point in the script, all we have to do is dump or concurrent dump.</p><p class="P1"># We are not checking the $DUMP varable because there is no other decision to make.</p><p class="P1"># Proceeding with dump operations...</p><p class="P1"> </p><p class="P1"># Make sure that dumpdir directory exists</p><p class="P1">if ! [ -d $DUMPDIR/ ]; then</p><p class="P1"><span> echo "$date_time : ERROR ABORT $script_name - $DUMPDIR does not exist!!"</span></p><p class="P1"><span> exit</span></p><p class="P1">fi</p><p class="P1"> </p><p class="P1"># If the lockfile file exists, then we have not completed a previous  backup operation.</p><p class="P1"># The backuppc server may still be collecting the dump from this host.</p><p class="P1"># The previous dump attempt may have prematurely failed.</p><p class="P1"># Do not start another dump if one is already in progress and/or the backuppc server has not yet invoked the dump cleanup script.</p><p class="P1">if [ -e $DUMPDIR/${lockfile}  ]; then</p><p class="P1"><span> echo " WARNING $script_name - WARNING backup and/or dump may already being runing."</span></p><p class="P1"><span> echo " =====&gt; detected lockfile at $DUMPDIR/$lockfile &lt;===== "</span></p><p class="P1"><span> echo " Dump may already be running. Use --clean option first to remove the lock and try again."</span></p><p class="P1"><span> exit</span></p><p class="P1">else</p><p class="P1"><span> # Create the lockfile and begin...</span></p><p class="P1"><span> echo "$date_time dump processing started" &gt; ${DUMPDIR}/${lockfile}</span></p><p class="P1"><span> echo "$date_time : $DUMPDIR/$lockfile created, proceeding with dump operation..."</span></p><p class="P1">fi</p><p class="P1"> </p><p class="P1"># Create the vm dump subdirectory if it does not already exist.</p><p class="P1">mkdir -p "$DUMPDIR/$dump_subdir"</p><p class="P1"> </p><p class="P1"># Use virsh to get an array of running VMs on the hypervisor.</p><p class="P1"># We want only the names of the VMs that are in the running state.</p><p class="P1">vms_running=($(virsh list --state-running --name))</p><p class="P1"> </p><p class="P1"># Pause each of the running VMs to ready them for the dump operation as perscribed by the "concurrent" option.</p><p class="P1"># Dump each of the previously running VMs</p><p class="P1">if [ ${#vms_running} -eq 0 ]; then</p><p class="P1"><span> echo "$date_time : no running VMs detected"</span></p><p class="P1">else</p><p class="P1"><span> # Suspend all running VMs only if we are not dumping concurrently. </span></p><p class="P1"><span> if [ $CONCURRENT -eq 0 ]; then</span></p><p class="P1"><span> </span><span> for i in "${vms_running[@]}"; do</span></p><p class="P1"><span> </span><span> </span><span> date_time=$(date)</span></p><p class="P1"><span> </span><span> </span><span> echo "$date_time : suspending VM  $i"</span></p><p class="P1"><span> </span><span> </span><span> virsh suspend "$i"</span></p><p class="P1"><span> </span><span> done</span></p><p class="P1"><span> fi</span></p><p class="P1"> </p><p class="P1"><span> # Dump VMs by creation of a temporary clone.</span></p><p class="P1"><span> for i in "${vms_running[@]}"</span></p><p class="P1"><span> do</span></p><p class="P1"><span> </span><span> # If concurrent, then suspend the respective VM</span></p><p class="P1"><span> </span><span> if [ $CONCURRENT -eq 1 ]; then</span></p><p class="P1"><span> </span><span> </span><span> date_time=$(date)</span></p><p class="P1"><span> </span><span> </span><span> echo "$date_time : concurrently suspending VM  $i"</span></p><p class="P1"><span> </span><span> </span><span> virsh suspend "$i"</span></p><p class="P1"><span> </span><span> fi</span></p><p class="P1"> </p><p class="P1"><span> </span><span> # Perform the VM clone dump...</span></p><p class="P1"><span> </span><span> create_and_dump_temporary_clone "$i"</span></p><p class="P1"> </p><p class="P1"><span> </span><span> # If concurrent, then resume the respective VM</span></p><p class="P1"><span> </span><span> if [ $CONCURRENT -eq 1 ]; then</span></p><p class="P1"><span> </span><span> </span><span> date_time=$(date)</span></p><p class="P1"><span> </span><span> </span><span> echo "$date_time : concurrently resuming VM  $i"</span></p><p class="P1"><span> </span><span> </span><span> virsh resume "$i"</span></p><p class="P1"><span> </span><span> fi</span></p><p class="P1"><span> done</span></p><p class="P1">fi</p><p class="P1"> </p><p class="P1"># Now we deal with the remaining VMs. The previously shutoff, or inactive ones.</p><p class="P1">vms_inactive=($(virsh list --inactive --name))</p><p class="P1">if [ ${#vms_inactive} -eq 0 ]; then</p><p class="P1"><span> echo "$date_time : no inactive VMs detected"</span></p><p class="P1">else</p><p class="P1"><span> # Dump VMs by creation of a temporary clone.</span></p><p class="P1"><span> for i in "${vms_inactive[@]}"</span></p><p class="P1"><span> do</span></p><p class="P1"><span> </span><span> create_and_dump_temporary_clone "$i"</span></p><p class="P1"><span> done</span></p><p class="P1">fi</p><p class="P1"> </p><p class="P1">if [ $CONCURRENT -eq 0 ]; then</p><p class="P1"><span> # Finally we resume all of the previously running VMs, to restore them to originally running state after all of the dumps have completed.</span></p><p class="P1"><span> if [ ${#vms_running} -eq 0 ]; then</span></p><p class="P1"><span> </span><span> echo "$date_time : There are no running VMs to resume"</span></p><p class="P1"><span> else</span></p><p class="P1"><span> </span><span> for i in "${vms_running[@]}"</span></p><p class="P1"><span> </span><span> do</span></p><p class="P1"><span> </span><span> </span><span> date_time=$(date)</span></p><p class="P1"><span> </span><span> </span><span> echo "$date_time : resuming VM $i"</span></p><p class="P1"><span> </span><span> </span><span> virsh resume "$i"</span></p><p class="P1"><span> </span><span> done</span></p><p class="P1"><span> fi</span></p><p class="P1">fi</p><p class="P1"> </p><p class="P1"><span> print_run_time</span></p><p class="P1"> </p><p class="P1">date_time=$(date)</p><p class="P1"># We are done for now. Exit</p><p class="P1">echo "$date_time : **************** COMPLETED $script_name"</p><p class="P1">exit</p><p class="P1"> </p></body></html>